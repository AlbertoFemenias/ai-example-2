<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Adivina la Fórmula</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f0f2f5;
            color: #333;
        }

        .screen {
            background-color: #ffffff;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            text-align: center;
            width: 90%;
            max-width: 850px;
        }

        h1, h2 {
            color: #2c3e50;
        }

        h1 {
            margin-bottom: 20px;
        }

        h2 {
            margin-top: 0;
            margin-bottom: 25px;
        }

        .options-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
            text-align: left;
        }

        .options-grid label {
            display: block;
            padding: 8px;
            background-color: #e9ecef;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .options-grid label:hover {
            background-color: #ced4da;
        }
        .options-grid input[type="checkbox"] {
            margin-right: 8px;
            vertical-align: middle;
        }

        select, button {
            padding: 12px 18px;
            font-size: 16px;
            border-radius: 5px;
            border: 1px solid #ced4da;
            cursor: pointer;
            margin: 5px;
            transition: background-color 0.2s, border-color 0.2s;
        }

        button {
            background-color: #007bff;
            color: white;
            border-color: #007bff;
        }
        button:hover:not(:disabled) {
            background-color: #0056b3;
            border-color: #0056b3;
        }
        button:disabled {
            background-color: #adb5bd;
            border-color: #adb5bd;
            cursor: not-allowed;
        }

        #game-info {
            font-size: 18px;
            margin-bottom: 15px;
            color: #495057;
        }

        #game-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
       
        #canvas-container {
            position: relative;
        }

        canvas {
            border: 1px solid #dee2e6;
            border-radius: 5px;
            background-color: #fff;
        }

        #options-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 100%;
            max-width: 300px;
        }
       
        @media (min-width: 800px) {
             #game-area {
                flex-direction: row;
                align-items: flex-start;
            }
            #options-container {
                width: 280px;
                min-width: 250px;
            }
        }

        .option-button {
            width: 100%;
            background-color: #f8f9fa;
            color: #343a40;
            border: 1px solid #ced4da;
            text-align: left;
            padding: 10px;
            font-family: 'Consolas', 'Menlo', 'Courier New', monospace;
        }
        .option-button.selected {
            background-color: #007bff;
            color: white;
            border-color: #0056b3;
        }
        .option-button.correct {
            background-color: #28a745;
            color: white;
            border-color: #1e7e34;
        }
        .option-button.incorrect {
            background-color: #dc3545;
            color: white;
            border-color: #b02a37;
        }

        #feedback {
            margin-top: 15px;
            font-size: 16px;
            font-weight: bold;
            min-height: 2em;
        }
        .feedback-correct {
            color: #28a745;
        }
        .feedback-incorrect {
            color: #dc3545;
        }
        #final-score {
            font-size: 20px;
            margin-bottom: 20px;
        }
        .equation-text {
            font-family: 'Consolas', 'Menlo', 'Courier New', monospace;
            padding: 2px 5px;
            background-color: #e9ecef;
            border-radius: 3px;
            display: inline-block;
        }
    </style>
</head>
<body>

    <div id="main-menu-screen" class="screen">
        <h1>Adivina la Fórmula</h1>
        <h2>Selecciona Familias de Ecuaciones:</h2>
        <div id="equation-family-selector" class="options-grid">
            </div>
       
        <h2>Número de Preguntas:</h2>
        <select id="num-questions-selector">
            <option value="5">5 Preguntas</option>
            <option value="10" selected>10 Preguntas</option>
            <option value="15">15 Preguntas</option>
            <option value="20">20 Preguntas</option>
            <option value="25">25 Preguntas</option>
        </select>
       
        <button id="start-game-button" disabled>Empezar Juego</button>
    </div>

    <div id="game-screen" class="screen" style="display:none;">
        <div id="game-info">Pregunta X de Y | Puntuación: A/B</div>
        <div id="game-area">
            <div id="canvas-container">
                <canvas id="plot-canvas" width="500" height="400"></canvas>
            </div>
            <div id="options-container">
                </div>
        </div>
        <div id="controls-feedback-area">
            <button id="confirm-answer-button" disabled>Confirmar Respuesta</button>
            <div id="feedback"></div>
            <button id="next-question-button" style="display:none;">Siguiente Pregunta</button>
        </div>
    </div>

    <div id="end-screen" class="screen" style="display:none;">
        <h1>¡Juego Terminado!</h1>
        <div id="final-score">Tu puntuación final es: X/Y</div>
        <button id="play-again-button">Jugar de Nuevo</button>
    </div>

    <script>
        const mainMenuScreen = document.getElementById('main-menu-screen');
        const gameScreen = document.getElementById('game-screen');
        const endScreen = document.getElementById('end-screen');

        const familySelectorContainer = document.getElementById('equation-family-selector');
        const numQuestionsSelector = document.getElementById('num-questions-selector');
        const startGameButton = document.getElementById('start-game-button');

        const gameInfoDisplay = document.getElementById('game-info');
        const canvas = document.getElementById('plot-canvas');
        const ctx = canvas.getContext('2d');
        const optionsContainer = document.getElementById('options-container');
        const confirmAnswerButton = document.getElementById('confirm-answer-button');
        const feedbackDisplay = document.getElementById('feedback');
        const nextQuestionButton = document.getElementById('next-question-button');

        const finalScoreDisplay = document.getElementById('final-score');
        const playAgainButton = document.getElementById('play-again-button');

        let currentScreen = 'menu';
        let selectedFamilies = [];
        let numQuestions = 10;
        let currentQuestionIndex = 0;
        let score = 0;
        let questions = [];
        let currentMysteryFunction = null;
        let currentOptions = [];
        let selectedOptionElement = null;
        let correctAnswerString = '';
        let axisBounds = { xmin: -10, xmax: 10, ymin: -10, ymax: 10 };

        function generateSineHelper() {
            let a = randomChoice([-2,-1.5,-1,-0.5,0.5,1,1.5,2]);
            let b = randomChoice([0.5, 1, 1.5, 2, Math.PI/2, Math.PI].map(val => formatNum(val, 2)));
            let d = randomInt(-3,3);
            let str_a = a === 1 ? '' : (a === -1 ? '-' : formatNum(a));
            return {
                func: x => a * Math.sin(b * x) + d,
                string: `y = ${str_a}sin(${formatNum(b)}x) ${d === 0 ? '' : (d > 0 ? `+ ${formatNum(Math.abs(d))}` : `- ${formatNum(Math.abs(d))}`)}`.trim(),
                coeffs: {a,b,d},
                familyName: 'Seno',
                familyId: 'sine'
            };
        }
        function generateCosineHelper() {
            let a = randomChoice([-2,-1.5,-1,-0.5,0.5,1,1.5,2]);
            let b = randomChoice([0.5, 1, 1.5, 2, Math.PI/2, Math.PI].map(val => formatNum(val, 2)));
            let d = randomInt(-3,3);
            let str_a = a === 1 ? '' : (a === -1 ? '-' : formatNum(a));
            return {
                func: x => a * Math.cos(b * x) + d,
                string: `y = ${str_a}cos(${formatNum(b)}x) ${d === 0 ? '' : (d > 0 ? `+ ${formatNum(Math.abs(d))}` : `- ${formatNum(Math.abs(d))}`)}`.trim(),
                coeffs: {a,b,d},
                familyName: 'Coseno',
                familyId: 'cosine'
            };
        }
       
        function generateTrigonometric() {
            let baseFuncData;
            if (Math.random() < 0.5) {
                baseFuncData = generateSineHelper();
            } else {
                baseFuncData = generateCosineHelper();
            }
            return {
                ...baseFuncData,
                familyName: 'Trigonométrica',
                familyId: 'trigonometric'
            };
        }

        const equationFamilies = [
            { name: 'Lineal', id: 'linear', generator: generateLinear, defaultXRange: [-10, 10] },
            { name: 'Cuadrática', id: 'quadratic', generator: generateQuadratic, defaultXRange: [-7, 7] },
            { name: 'Cúbica', id: 'cubic', generator: generateCubic, defaultXRange: [-5, 5] },
            { name: 'Valor Absoluto', id: 'absolute', generator: generateAbsolute, defaultXRange: [-7, 7] },
            { name: 'Raíz Cuadrada', id: 'sqrt', generator: generateSqrt, defaultXRangeFn: () => [0, 15] },
            { name: 'Exponencial', id: 'exponential', generator: generateExponential, defaultXRange: [-4, 4] },
            { name: 'Logarítmica', id: 'logarithmic', generator: generateLogarithmic, defaultXRangeFn: () => [0.01, 10] },
            {
                name: 'Trigonométrica',
                id: 'trigonometric',
                generator: generateTrigonometric,
                defaultXRangeFn: (coeffs) => {
                    const period = 2 * Math.PI / Math.abs(coeffs.b || 1);
                    return [-period, period];
                }
            },
        ];


        // --- Utility Functions ---
        function randomFloat(min, max, decimals = 2) {
            const factor = Math.pow(10, decimals);
            return Math.round((Math.random() * (max - min) + min) * factor) / factor;
        }
        function randomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }
        function randomChoice(arr) {
            return arr[Math.floor(Math.random() * arr.length)];
        }
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }
        function formatNum(n, p = 2) {
            if (typeof n !== 'number') return n;
            const val = parseFloat(n.toFixed(p));
            if (Object.is(val, -0)) return 0;
            return val;
        }
        const htmlSup = (text) => `<sup>${text}</sup>`;
        const htmlSub = (text) => `<sub>${text}</sub>`;

        // --- Equation Generators (setting familyName and familyId) ---
        function generateLinear() {
            let a = randomChoice([-4,-3,-2,-1,-0.5, 0.5,1,2,3,4].map(v=>formatNum(v,1)));
            let b = randomInt(-8, 8);
            
            let str_a_part = "";
            if (a === 1) str_a_part = "x";
            else if (a === -1) str_a_part = "-x";
            else if (a !== 0) str_a_part = `${formatNum(a)}x`;
            // if a is 0, str_a_part remains ""

            let str_b_part = "";
            if (b > 0) str_b_part = `+ ${formatNum(b)}`;
            else if (b < 0) str_b_part = `- ${formatNum(Math.abs(b))}`;
            // if b is 0, str_b_part remains ""

            let final_string = "y = ";
            if (str_a_part !== "") {
                final_string += str_a_part;
                if (str_b_part !== "" && b > 0) final_string += ` ${str_b_part}`; // Add space if a and b parts exist
                else if (str_b_part !== "") final_string += ` ${str_b_part}`; // Handles negative b
            } else { // a is 0
                final_string += `${formatNum(b)}`;
            }
            if (a !== 0 && b === 0 && str_a_part !== "") { // e.g. y = 2x
                 // final_string already covers this
            } else if (a === 0 && b === 0) { // y = 0
                final_string = `y = 0`;
            }
            
            return {
                func: x => a * x + b,
                string: final_string.replace(/\s\+\s0$/, '').replace(/\s-\s0$/, '').trim(), // Remove +0 or -0 at the end
                coeffs: {a, b},
                familyName: 'Lineal', familyId: 'linear'
            };
        }

        function generateQuadratic() {
            let a = randomChoice([-2, -1, -0.5, -0.25, 0.25, 0.5, 1, 2].map(v=>formatNum(v,2)));
            let k = randomInt(-10, 10);
            let str_k = k === 0 ? '' : (k > 0 ? `+ ${formatNum(Math.abs(k))}` : `- ${formatNum(Math.abs(k))}`);
            let str_a = a === 1 ? '' : (a === -1 ? '-' : formatNum(a));
            return {
                func: x => a * x * x + k,
                string: `y = ${str_a}x${htmlSup('2')} ${str_k}`.trim(),
                coeffs: {a, k},
                familyName: 'Cuadrática', familyId: 'quadratic'
            };
        }
       
        function generateCubic() {
            let a = randomChoice([-0.5, -0.2, -0.1, 0.1, 0.2, 0.5].map(v=>formatNum(v,1)));
            let d = randomInt(-5, 5);
            let str_d = d === 0 ? '' : (d > 0 ? `+ ${formatNum(Math.abs(d))}` : `- ${formatNum(Math.abs(d))}`);
            let str_a = a === 1 ? '' : (a === -1 ? '-' : formatNum(a));
            return {
                func: x => a * x*x*x + d,
                string: `y = ${str_a}x${htmlSup('3')} ${str_d}`.trim(),
                coeffs: {a,d},
                familyName: 'Cúbica', familyId: 'cubic'
            };
        }

        function generateAbsolute() {
            let a = randomChoice([-3,-2,-1,-0.5,0.5,1,2,3].map(v=>formatNum(v,1)));
            let k = randomInt(-5, 5);
            let str_k = k === 0 ? '' : (k > 0 ? `+ ${formatNum(Math.abs(k))}` : `- ${formatNum(Math.abs(k))}`);
            let str_a = a === 1 ? '' : (a === -1 ? '-' : formatNum(a));
            return {
                func: x => a * Math.abs(x) + k,
                string: `y = ${str_a}|x| ${str_k}`.trim(),
                coeffs: {a,k},
                familyName: 'Valor Absoluto', familyId: 'absolute'
            };
        }

        function generateSqrt() {
            let a = randomChoice([-3,-2,-1,1,2,3]);
            let k = randomInt(-5, 5);
            let str_k = k === 0 ? '' : (k > 0 ? `+ ${formatNum(Math.abs(k))}` : `- ${formatNum(Math.abs(k))}`);
            let str_a = a === 1 ? '' : (a === -1 ? '-' : formatNum(a));
            return {
                func: x => {
                    if (x < 0) return NaN;
                    return a * Math.sqrt(x) + k;
                },
                string: `y = ${str_a}√x ${str_k}`.trim(),
                coeffs: {a,k},
                familyName: 'Raíz Cuadrada', familyId: 'sqrt'
            };
        }
       
        function generateExponential() {
            let a = randomChoice([-2,-1,-0.5,0.5,1,2].map(v=>formatNum(v,1)));
            let b_val = randomChoice([0.5, 0.7, 1.5, 1.8, 2].map(v=>formatNum(v,1)));
            let c = randomInt(-5,5);
            let str_c = c === 0 ? '' : (c > 0 ? `+ ${formatNum(Math.abs(c))}` : `- ${formatNum(Math.abs(c))}`);
            
            let string_a_mult = "";
            if (a === 1) string_a_mult = ""; // y = b^x
            else if (a === -1) string_a_mult = "-"; // y = -b^x
            else if (a !== 0) string_a_mult = `${formatNum(a)} * `; // y = a * b^x
            // If a is 0, the whole term a * b^x is 0.
            
            let final_string;
            if (a === 0) { // y = c
                final_string = `y = ${formatNum(c)}`;
            } else {
                final_string = `y = ${string_a_mult}${formatNum(b_val)}${htmlSup('x')} ${str_c}`.trim();
            }

            return {
                func: x => a * Math.pow(b_val, x) + c,
                string: final_string,
                coeffs: {a,b: b_val,c},
                familyName: 'Exponencial', familyId: 'exponential'
            };
        }

        function generateLogarithmic() {
            let a = randomChoice([-2,-1,-0.5,0.5,1,2].map(v=>formatNum(v,1)));
            let base = randomChoice([2, Math.E, 3, 10]);
            let k = randomInt(-5, 5);
            
            const isNaturalLog = base === Math.E;
            const isCommonLogExplicitBase = base === 10 && Math.random() < 0.3; // Sometimes show base 10 explicitly
            const isCommonLogImplicitBase = base === 10 && !isNaturalLog && !isCommonLogExplicitBase;

            let logSymbol;
            let baseDisplay = "";

            if (isNaturalLog) {
                logSymbol = "ln";
            } else if (isCommonLogImplicitBase) {
                logSymbol = "log";
            } else { // Other bases or explicit base 10
                logSymbol = "log";
                baseDisplay = htmlSub(formatNum(base,1));
            }
            
            let str_k = k === 0 ? '' : (k > 0 ? `+ ${formatNum(Math.abs(k))}` : `- ${formatNum(Math.abs(k))}`);
            let str_a = a === 1 ? '' : (a === -1 ? '-' : formatNum(a));
            if (a === 0) str_a = '0'; // Should result in y = k

            let final_string;
            if (a === 0) {
                final_string = `y = ${formatNum(k)}`;
            } else {
                final_string = `y = ${str_a}${logSymbol}${baseDisplay}(x) ${str_k}`.trim();
            }


            return {
                func: x => {
                    if (x <= 0) return NaN;
                    if (base === Math.E) return a * Math.log(x) + k;
                    return a * (Math.log(x) / Math.log(base)) + k;
                },
                string: final_string,
                coeffs: {a,base,k},
                familyName: 'Logarítmica', familyId: 'logarithmic'
            };
        }


        // --- Game Logic ---
        function populateFamilySelector() {
            familySelectorContainer.innerHTML = '';
            equationFamilies.forEach(family => {
                const label = document.createElement('label');
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.value = family.id;
                checkbox.checked = true;
                checkbox.addEventListener('change', updateStartButtonState);
                label.appendChild(checkbox);
                label.appendChild(document.createTextNode(" " + family.name));
                familySelectorContainer.appendChild(label);
            });
            updateStartButtonState();
        }

        function updateStartButtonState() {
            selectedFamilies = Array.from(familySelectorContainer.querySelectorAll('input[type="checkbox"]:checked'))
                                  .map(cb => cb.value);
            startGameButton.disabled = selectedFamilies.length === 0;
        }

        /**
         * Generates distractor equations.
         * All distractors will be from a different family than the correct answer.
         * It will try to make distractor families unique from each other if possible.
         */
        function generateDistractors(correctFuncData, _allSelectedFamilyIds_unused_for_now) {
            const distractors = [];
            const correctFamilyId = correctFuncData.familyId;

            // Pool of all families *except* the correct one
            let otherFamilyDetailsPool = equationFamilies.filter(f => f.id !== correctFamilyId);
            shuffleArray(otherFamilyDetailsPool); // Randomize to pick different types of distractors

            const distractorStrings = new Set();
            distractorStrings.add(correctFuncData.string); // Don't generate a distractor identical to correct

            // Try to get up to 4 distractors, ideally from unique families first
            for (let i = 0; i < otherFamilyDetailsPool.length && distractors.length < 4; i++) {
                const familyToUse = otherFamilyDetailsPool[i];
                let distractor;
                let attempts = 0;
                const maxAttemptsPerFamily = 5; // Try a few times to get a unique string from this family

                do {
                    distractor = familyToUse.generator();
                    attempts++;
                } while (distractorStrings.has(distractor.string) && attempts < maxAttemptsPerFamily);

                if (!distractorStrings.has(distractor.string)) {
                    distractors.push(distractor);
                    distractorStrings.add(distractor.string);
                }
            }

            // If we still need more distractors (e.g., < 4 and ran out of unique families,
            // or failed to generate unique strings from them),
            // pick randomly from the `otherFamilyDetailsPool`, allowing family repetition among distractors.
            let emergencyFillAttempts = 0;
            while (distractors.length < 4 && otherFamilyDetailsPool.length > 0 && emergencyFillAttempts < 20) {
                const familyToUse = randomChoice(otherFamilyDetailsPool); // Pick a random "other" family
                const distractor = familyToUse.generator();

                // Add if its string is new, or if we are desperate and it's not the correct answer
                if (!distractorStrings.has(distractor.string)) {
                    distractors.push(distractor);
                    distractorStrings.add(distractor.string);
                } else if (distractors.length < 4 && distractor.string !== correctFuncData.string) {
                    // String is a duplicate of another distractor, but we need to fill.
                    // And it's not the correct answer.
                    distractors.push(distractor); // Add it anyway
                }
                emergencyFillAttempts++;
            }
            return distractors; // Returns what it could generate, `generateQuestions` will ensure exactly 4 are used.
        }


        function generateQuestions() {
            questions = [];
            const availableFamilyObjects = equationFamilies.filter(f => selectedFamilies.includes(f.id));
            if(availableFamilyObjects.length === 0) {
                alert("Por favor, selecciona al menos una familia de ecuaciones para empezar el juego.");
                return;
            }
             if (equationFamilies.length < 2 && availableFamilyObjects.length > 0) { // Needs at least 2 families *defined in the game*
                 alert("Se necesitan al menos dos tipos de familias de ecuaciones definidas en el juego para que los distractores sean de un tipo diferente. Este juego parece no tener suficientes tipos de ecuaciones definidas.");
                 startGameButton.disabled = true; // Disable start if this fundamental condition isn't met
                 return;
             }


            for (let i = 0; i < numQuestions; i++) {
                const familyDetails = randomChoice(availableFamilyObjects);
                const mysteryFuncData = familyDetails.generator();
               
                // Generate distractors using the new logic
                let distractors = generateDistractors(mysteryFuncData, selectedFamilies); // selectedFamilies is not used by new func but kept for signature
                
                // Ensure we have enough distractors (aiming for 4).
                // This loop will top up if generateDistractors returned < 4.
                let topUpAttempts = 0;
                const maxTopUpAttempts = 30; // Safety break
                while(distractors.length < 4 && topUpAttempts < maxTopUpAttempts) {
                    const potentialFillFamilies = equationFamilies.filter(f => f.id !== mysteryFuncData.familyId);
                    
                    if (potentialFillFamilies.length === 0) {
                        console.error("No hay familias alternativas para generar distractores de relleno. Esto no debería suceder si hay >1 familia definida.");
                        break; 
                    }

                    const fillFamily = randomChoice(potentialFillFamilies);
                    const dFill = fillFamily.generator();
                    
                    let isDuplicateAmongDistractors = distractors.some(d => d.string === dFill.string);
                    let isCorrectAnswer = dFill.string === mysteryFuncData.string;
                    
                    if (!isDuplicateAmongDistractors && !isCorrectAnswer) {
                        distractors.push(dFill);
                    } else if (distractors.length < 4 && !isCorrectAnswer) {
                        // If it's a duplicate string *among distractors* but not the correct answer,
                        // and we still need to fill, add it. This prioritizes family difference over string uniqueness among distractors.
                        distractors.push(dFill);
                    }
                    topUpAttempts++;
                }
                
                const finalDistractors = distractors.slice(0, 4); // Take the first 4.
                
                if (finalDistractors.length < 4) {
                     console.warn(`Pregunta ${i+1}: No se pudieron generar 4 distractores únicos y diferentes de la familia correcta. Se mostrarán ${finalDistractors.length} distractores.`);
                     // Game can proceed with fewer options if absolutely necessary, though UI expects 5 total (1 correct + 4 distractors).
                     // If this happens, it might indicate very limited coefficient variety or too few family types overall.
                }

                const options = [mysteryFuncData, ...finalDistractors];
                shuffleArray(options);
               
                questions.push({
                    mysteryFunctionData: mysteryFuncData,
                    options: options,
                    correctAnswerString: mysteryFuncData.string,
                    familyDetailsForBounds: familyDetails
                });
            }
        }
       
        function calculateAxisBounds(mysteryFuncData, options, familyDetailsForBounds) {
            const functionsToConsider = [mysteryFuncData, ...options.filter(opt => opt && typeof opt.func === 'function')];
           
            let xDataMin, xDataMax;
            if (typeof familyDetailsForBounds.defaultXRangeFn === 'function') {
                [xDataMin, xDataMax] = familyDetailsForBounds.defaultXRangeFn(mysteryFuncData.coeffs);
            } else {
                [xDataMin, xDataMax] = familyDetailsForBounds.defaultXRange || [-10, 10];
            }

            if (xDataMin >= xDataMax) { // Fallback for invalid range
                xDataMin = -5; xDataMax = 5;
                if (familyDetailsForBounds.id === 'sqrt' ) { xDataMin = 0; xDataMax = 10; }
                if (familyDetailsForBounds.id === 'logarithmic') { xDataMin = 0.01; xDataMax = 10; }
            }

            let allYValues = [];
            const numSamplePoints = 200; // Sample points across the initial x-range for Y auto-scaling
            const dxInitial = (xDataMax - xDataMin) / Math.max(1, numSamplePoints); // Avoid division by zero if xDataMin=xDataMax

            for (const funcData of functionsToConsider) {
                if (!funcData || typeof funcData.func !== 'function') continue;
                for (let i = 0; i <= numSamplePoints; i++) {
                    const x = xDataMin + i * dxInitial;
                    try {
                        const y = funcData.func(x);
                        if (!isNaN(y) && isFinite(y)) {
                            allYValues.push(y);
                        }
                    } catch (e) { /* ignore errors during sampling */ }
                }
            }
           
            if (allYValues.length === 0) allYValues = [-5, 5]; // Default Y if no valid points found

            let yDataMin = Math.min(...allYValues);
            let yDataMax = Math.max(...allYValues);

            if (yDataMin === yDataMax) { yDataMin -= 1; yDataMax += 1; } // Ensure some Y span

            const paddingFactor = 0.15; 
            let currentXSpan = xDataMax - xDataMin;
            let currentYSpan = yDataMax - yDataMin;

            // Ensure spans are not zero before padding
            currentXSpan = currentXSpan === 0 ? 2 : currentXSpan;
            currentYSpan = currentYSpan === 0 ? 2 : currentYSpan;

            let xSpanDataPadded = currentXSpan * (1 + 2 * paddingFactor);
            let ySpanDataPadded = currentYSpan * (1 + 2 * paddingFactor);
           
            const xDataCenter = (xDataMin + xDataMax) / 2;
            const yDataCenter = (yDataMin + yDataMax) / 2;
           
            const canvasAspectRatio = canvas.width / canvas.height;
           
            let finalXSpan = xSpanDataPadded;
            let finalYSpan = ySpanDataPadded;

            // Adjust span to fit canvas aspect ratio
            if (finalXSpan / finalYSpan > canvasAspectRatio) { 
                finalYSpan = finalXSpan / canvasAspectRatio;
            } else { 
                finalXSpan = finalYSpan * canvasAspectRatio;
            }
           
            axisBounds = {
                xmin: xDataCenter - finalXSpan / 2,
                xmax: xDataCenter + finalXSpan / 2,
                ymin: yDataCenter - finalYSpan / 2,
                ymax: yDataCenter + finalYSpan / 2,
            };
            // Final sanity check on bounds
            if (!Object.values(axisBounds).every(v => isFinite(v)) || axisBounds.xmin >= axisBounds.xmax || axisBounds.ymin >= axisBounds.ymax) {
                console.warn("Calculated axis bounds are invalid, resetting to a safe default.", axisBounds);
                let xFallbackMin = -10, xFallbackMax = 10;
                if (typeof familyDetailsForBounds.defaultXRangeFn === 'function') {
                    [xFallbackMin, xFallbackMax] = familyDetailsForBounds.defaultXRangeFn(mysteryFuncData.coeffs);
                } else if (familyDetailsForBounds.defaultXRange) {
                    [xFallbackMin, xFallbackMax] = familyDetailsForBounds.defaultXRange;
                }
                axisBounds.xmin = xFallbackMin; axisBounds.xmax = xFallbackMax;
                
                // Quick Y estimate for fallback
                let yValsDefault = [];
                const tempDx = (axisBounds.xmax - axisBounds.xmin) / 20 || 1;
                for(let xPlot = axisBounds.xmin; xPlot <= axisBounds.xmax; xPlot += tempDx) {
                    try {
                        const yVal = mysteryFuncData.func(xPlot);
                        if(isFinite(yVal)) yValsDefault.push(yVal);
                    } catch(e){}
                }
                if(yValsDefault.length > 0) {
                    axisBounds.ymin = Math.min(...yValsDefault) -1;
                    axisBounds.ymax = Math.max(...yValsDefault) +1;
                    if (axisBounds.ymin >= axisBounds.ymax) { axisBounds.ymin -=1; axisBounds.ymax +=1;}
                } else {
                    axisBounds.ymin = -10; axisBounds.ymax = 10;
                }
                 if (axisBounds.xmin >= axisBounds.xmax) {axisBounds.xmin = -10; axisBounds.xmax = 10;}
                 if (axisBounds.ymin >= axisBounds.ymax) {axisBounds.ymin = -10; axisBounds.ymax = 10;}
            }
        }

        function calculateNiceTicks(minVal, maxVal, maxTicks = 8) {
            const range = maxVal - minVal;
            if (!isFinite(range) || range < 0) { // Invalid range
                 return { ticks: [minVal || 0], step: 1};
            }
            if (range === 0) return { ticks: [minVal], step: 0 };


            const roughStep = range / Math.max(1, (maxTicks - 1));
            if (!isFinite(roughStep) || roughStep <=0 ) { // Invalid rough step
                return {ticks: [minVal, maxVal], step: range || 1};
            }


            const exponent = Math.floor(Math.log10(roughStep));
            const magnitude = Math.pow(10, exponent);
            const possibleStepsMultipliers = [1, 2, 2.5, 5, 10]; // Common "nice" multipliers
           
            let niceStep = possibleStepsMultipliers[possibleStepsMultipliers.length-1] * magnitude; // Default to largest

            for(let pStep of possibleStepsMultipliers) {
                if (pStep * magnitude >= roughStep) {
                    niceStep = pStep * magnitude;
                    break;
                }
            }
             if (!isFinite(niceStep) || niceStep <= 0) niceStep = (magnitude > 0 && isFinite(magnitude)) ? magnitude : 1; // Fallback for niceStep

            const firstTickUnrounded = Math.floor(minVal / niceStep) * niceStep;
            const firstTick = parseFloat(firstTickUnrounded.toFixed(10)); // Mitigate floating point issues
            const ticks = [];
            let currentTick = firstTick;
           
            const safetyMaxTicksLoop = maxTicks * 3 + 5; // Generous safety for loop
            // Add ticks as long as they are within or very near the extended range
            while (currentTick < maxVal + niceStep * 0.5 && ticks.length < safetyMaxTicksLoop) {
                ticks.push(parseFloat(currentTick.toFixed(10))); // Mitigate floating point issues for pushed ticks
                currentTick += niceStep;
                 if (niceStep === 0) break; // Avoid infinite loop if step becomes 0
            }
            
            // Ensure at least two ticks if range is valid and non-zero
            if (ticks.length < 2 && isFinite(minVal) && isFinite(maxVal) && minVal < maxVal) {
                 ticks.length = 0; // Clear previous attempts if too few
                 ticks.push(formatNum(minVal));
                 ticks.push(formatNum(maxVal));
                 ticks.sort((a,b) => a-b); // Ensure order
                 // Remove duplicates that might arise from formatNum if minVal and maxVal are very close
                 if (ticks.length > 1 && ticks[0] === ticks[1]) ticks.pop();
            }
            if (ticks.length === 0 && isFinite(minVal)) { // If all else fails, at least one tick
                 ticks.push(formatNum(minVal));
            }


            return { ticks, step: niceStep };
        }


        function renderAxis() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.font = '10px Arial';

            let { xmin, xmax, ymin, ymax } = axisBounds; // Make mutable copies for local adjustments
            if (![xmin, xmax, ymin, ymax].every(val => typeof val === 'number' && isFinite(val)) || xmin >= xmax || ymin >= ymax ) {
                console.error("Invalid axis bounds for rendering:", axisBounds);
                xmin = -10; xmax = 10; ymin = -10; ymax = 10; // Fallback to absolute default
                axisBounds = {xmin, xmax, ymin, ymax}; // Update global if it was critically bad
            }
           
            const numXTicks = Math.max(2, Math.min(10, Math.floor(canvas.width / 60)));
            const numYTicks = Math.max(2, Math.min(8, Math.floor(canvas.height / 50)));

            const xTicksData = calculateNiceTicks(xmin, xmax, numXTicks);
            const yTicksData = calculateNiceTicks(ymin, ymax, numYTicks);

            const toCanvasX = (mathX) => (mathX - xmin) / (xmax - xmin) * canvas.width;
            const toCanvasY = (mathY) => canvas.height - (mathY - ymin) / (ymax - ymin) * canvas.height;

            ctx.strokeStyle = '#eee'; // Grid lines
            ctx.lineWidth = 1;
            xTicksData.ticks.forEach(tick => {
                const xPos = toCanvasX(tick);
                if(xPos >=0 && xPos <= canvas.width && isFinite(xPos)){
                    ctx.beginPath(); ctx.moveTo(xPos, 0); ctx.lineTo(xPos, canvas.height); ctx.stroke();
                }
            });
            yTicksData.ticks.forEach(tick => {
                const yPos = toCanvasY(tick);
                 if(yPos >=0 && yPos <= canvas.height && isFinite(yPos)){
                    ctx.beginPath(); ctx.moveTo(0, yPos); ctx.lineTo(canvas.width, yPos); ctx.stroke();
                 }
            });
           
            ctx.strokeStyle = '#888'; // Axis lines
            ctx.lineWidth = 1.5;
            if (ymin <= 0 && ymax >= 0) { // Draw X-axis if 0 is in Y range
                const yZero = toCanvasY(0);
                if(isFinite(yZero)) {ctx.beginPath(); ctx.moveTo(0, yZero); ctx.lineTo(canvas.width, yZero); ctx.stroke();}
            }
            if (xmin <= 0 && xmax >= 0) { // Draw Y-axis if 0 is in X range
                const xZero = toCanvasX(0);
                if(isFinite(xZero)) {ctx.beginPath(); ctx.moveTo(xZero, 0); ctx.lineTo(xZero, canvas.height); ctx.stroke();}
            }

            ctx.fillStyle = '#555'; // Tick labels
            const yAxisCanvasPos = toCanvasY(0); 
            
            ctx.textAlign = 'center';
            xTicksData.ticks.forEach(tick => {
                const xPos = toCanvasX(tick);
                if(!isFinite(xPos)) return;
                let labelTextY = yAxisCanvasPos + 5; 
                ctx.textBaseline = 'top';

                if (yAxisCanvasPos > canvas.height - 15) { 
                    labelTextY = canvas.height - 2; ctx.textBaseline = 'bottom';
                } else if (yAxisCanvasPos < 15 && !(ymin <= 0 && ymax >=0)) { // If X-axis isn't drawn low
                    labelTextY = 2; ctx.textBaseline = 'top';
                } else if (yAxisCanvasPos < 15) { // X-axis is drawn, label above it
                     labelTextY = yAxisCanvasPos -2; ctx.textBaseline = 'bottom';
                }

                if(xPos >=-10 && xPos <= canvas.width + 10) { 
                    const prec = (Math.abs(tick) < 0.1 && tick !== 0) ? 2 : ((Math.abs(tick) < 10 && tick !== 0 && (tick % 1 !== 0)) ? 1 : 0);
                    ctx.fillText(formatNum(tick, prec), xPos, labelTextY);
                }
            });

            ctx.textBaseline = 'middle';
            const xAxisCanvasPos = toCanvasX(0); 
            yTicksData.ticks.forEach(tick => {
                const yPos = toCanvasY(tick);
                if(!isFinite(yPos)) return;
                let labelTextX = xAxisCanvasPos - 5;
                ctx.textAlign = 'right';

                if (xAxisCanvasPos < 25 && !(xmin <= 0 && xmax >=0) ) { // Y-axis not drawn on left
                    labelTextX = 5; ctx.textAlign = 'left';
                } else if (xAxisCanvasPos < 25) { // Y-axis drawn, label to its right
                     labelTextX = xAxisCanvasPos + 5; ctx.textAlign = 'left';
                } else if (xAxisCanvasPos > canvas.width - 25) {
                    labelTextX = canvas.width - 5; ctx.textAlign = 'right';
                }
                
                 if(yPos >= -10 && yPos <= canvas.height + 10){ 
                    const prec = (Math.abs(tick) < 0.1 && tick !== 0) ? 2 : ((Math.abs(tick) < 10 && tick !== 0 && (tick % 1 !== 0)) ? 1 : 0);
                    if (tick === 0 && (xmin > 0 || xmax < 0)) {} // Don't double-label origin if Y-axis is off-screen
                    else ctx.fillText(formatNum(tick, prec), labelTextX, yPos);
                 }
            });
            ctx.textAlign = 'left'; ctx.textBaseline = 'alphabetic'; // Reset to defaults
        }

        function plotFunction(func, color) {
            const { xmin, xmax, ymin, ymax } = axisBounds;
            if (![xmin, xmax, ymin, ymax].every(val => typeof val === 'number' && isFinite(val)) || xmin >= xmax || ymin >= ymax) {
                 console.warn("Skipping plot due to invalid axis bounds:", axisBounds);
                 return;
            }

            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = 2.5;

            const plotSteps = canvas.width * 2; // Number of segments to draw for the function plot
            const dx = (xmax - xmin) / plotSteps;
            if (dx === 0 || !isFinite(dx)) {
                console.warn("Skipping plot due to invalid dx (step size):", dx);
                return;
            }

            let firstPoint = true;

            for (let i = 0; i <= plotSteps; i++) {
                const mathX = xmin + i * dx;
                let mathY;
                try { mathY = func(mathX); } catch(e) { mathY = NaN; } // Catch errors from function execution
               
                // Define a plotting window slightly larger than the viewport to handle curves going off-screen smoothly
                const yRangeViewport = ymax - ymin;
                const yPlotMin = ymin - yRangeViewport * 0.5; // Allow some overshoot
                const yPlotMax = ymax + yRangeViewport * 0.5;

                if (isNaN(mathY) || !isFinite(mathY) || mathY < yPlotMin || mathY > yPlotMax) {
                    // If point is NaN, infinite, or way off screen, start a new path segment
                    firstPoint = true;
                    continue;
                }

                const canvasX = (mathX - xmin) / (xmax - xmin) * canvas.width;
                const canvasY = canvas.height - (mathY - ymin) / (ymax - ymin) * canvas.height;
               
                 if (!isFinite(canvasX) || !isFinite(canvasY)) { // Additional check for canvas coordinates
                    firstPoint = true;
                    continue;
                }

                if (firstPoint) {
                    ctx.moveTo(canvasX, canvasY);
                    firstPoint = false;
                } else {
                    ctx.lineTo(canvasX, canvasY);
                }
            }
            ctx.stroke();
        }

        function loadQuestion(index) {
            currentQuestionIndex = index;
            const questionData = questions[index];
            if (!questionData) {
                console.error(`Error: No hay datos para la pregunta ${index}. Finalizando juego.`);
                showEndScreen(); 
                return;
            }
            if (!questionData.mysteryFunctionData || typeof questionData.mysteryFunctionData.func !== 'function') {
                console.error(`Error: Función misteriosa inválida para la pregunta ${index}.`, questionData.mysteryFunctionData);
                nextQuestion(); // Skip to next or end
                return;
            }

            currentMysteryFunction = questionData.mysteryFunctionData.func;
            correctAnswerString = questionData.correctAnswerString;
            currentOptions = questionData.options;

            if (!currentOptions || currentOptions.length === 0) {
                 console.error(`Error: No hay opciones para la pregunta ${index}. Ecuación correcta: ${correctAnswerString}`);
                 nextQuestion(); 
                 return;
            }


            gameInfoDisplay.textContent = `Pregunta ${index + 1} de ${numQuestions} | Puntuación: ${score}/${index}`;
           
            calculateAxisBounds(questionData.mysteryFunctionData, questionData.options, questionData.familyDetailsForBounds);
            renderAxis();
            plotFunction(currentMysteryFunction, 'blue');

            optionsContainer.innerHTML = '';
            currentOptions.forEach(opt => {
                if (!opt || typeof opt.string === 'undefined') { // Basic check for malformed option
                    console.warn("Opción malformada encontrada y omitida:", opt, "en pregunta:", questionData);
                    return; 
                }
                const button = document.createElement('button');
                button.classList.add('option-button');
                button.innerHTML = opt.string; //innerHTML allows for <sup> etc.
                button.dataset.equation = opt.string; 
                button.addEventListener('click', () => selectOption(button, opt));
                optionsContainer.appendChild(button);
            });

            confirmAnswerButton.disabled = true;
            nextQuestionButton.style.display = 'none';
            feedbackDisplay.textContent = '';
            feedbackDisplay.className = '';
            selectedOptionElement = null;
            document.getElementById('canvas-container').style.visibility = 'visible';
            optionsContainer.style.visibility = 'visible';
        }

        function selectOption(buttonElement, optionData) {
            if (selectedOptionElement) {
                selectedOptionElement.classList.remove('selected');
            }
            selectedOptionElement = buttonElement;
            selectedOptionElement.classList.add('selected');
            confirmAnswerButton.disabled = false;
        }

        function confirmAnswer() {
            if (!selectedOptionElement) return;

            const selectedEquationString = selectedOptionElement.dataset.equation;
            const chosenOptionData = currentOptions.find(opt => opt.string === selectedEquationString);

            // Plot the chosen function in red if it's incorrect and is a plottable function
            if (chosenOptionData && typeof chosenOptionData.func === 'function' && selectedEquationString !== correctAnswerString) {
                 plotFunction(chosenOptionData.func, '#FF6347'); // Tomato red for incorrect choices
            }

            optionsContainer.querySelectorAll('.option-button').forEach(btn => {
                btn.disabled = true;
                if (btn.dataset.equation === correctAnswerString) {
                    btn.classList.add('correct'); // Mark the correct button green
                }
            });

            if (selectedEquationString === correctAnswerString) {
                score++;
                feedbackDisplay.textContent = "¡Correcto!";
                feedbackDisplay.className = 'feedback-correct';
                // selectedOptionElement already marked 'correct' by the loop above if it was the right one
            } else {
                feedbackDisplay.innerHTML = `Incorrecto. La respuesta correcta era: <span class="equation-text">${correctAnswerString}</span>`;
                feedbackDisplay.className = 'feedback-incorrect';
                 if (selectedOptionElement) { // If an option was indeed selected
                    selectedOptionElement.classList.remove('selected'); // remove general 'selected' style
                    selectedOptionElement.classList.add('incorrect'); // add specific 'incorrect' style (red)
                 }
            }
           
            gameInfoDisplay.textContent = `Pregunta ${currentQuestionIndex + 1} de ${numQuestions} | Puntuación: ${score}/${currentQuestionIndex + 1}`;
            confirmAnswerButton.disabled = true;
            nextQuestionButton.style.display = 'inline-block';
        }
       
        function nextQuestion() {
            if (currentQuestionIndex < numQuestions - 1) {
                loadQuestion(currentQuestionIndex + 1);
            } else {
                showEndScreen();
            }
        }

        function showEndScreen() {
            finalScoreDisplay.textContent = `Tu puntuación final es: ${score}/${numQuestions}`;
            showScreen('end');
        }

        function showScreen(screenId) {
            mainMenuScreen.style.display = 'none';
            gameScreen.style.display = 'none';
            endScreen.style.display = 'none';
            const targetScreen = document.getElementById(screenId + '-screen');
            if (targetScreen) {
                targetScreen.style.display = 'block';
            }
            currentScreen = screenId;
        }
       
        function resetGame() {
            score = 0;
            currentQuestionIndex = 0;
            questions = [];
            // Re-populate selector and enable start button if families are checked
            populateFamilySelector(); 
            // Start button state will be updated by populateFamilySelector's call to updateStartButtonState
        }

        startGameButton.addEventListener('click', () => {
            numQuestions = parseInt(numQuestionsSelector.value);
            generateQuestions(); // This populates the `questions` array
            if (questions.length > 0 && questions[0] && questions[0].options && questions[0].options.length > 0) {
                loadQuestion(0);
                showScreen('game');
            } else if (questions.length === 0 && selectedFamilies.length > 0) {
                 // This case implies generateQuestions failed silently or availableFamilyObjects was empty
                 // but was not caught by earlier checks.
                 alert("No se pudieron generar preguntas. Verifica la selección de familias o contacta al desarrollador.");
            } else if (selectedFamilies.length === 0) {
                // This case should be prevented by startGameButton.disabled state.
                alert("Por favor, selecciona al menos una familia de ecuaciones.");
            }
        });

        confirmAnswerButton.addEventListener('click', confirmAnswer);
        nextQuestionButton.addEventListener('click', nextQuestion);
        playAgainButton.addEventListener('click', () => {
            resetGame();
            showScreen('main-menu');
        });

        // Initialize
        populateFamilySelector();
        showScreen('main-menu');
    </script>
</body>
</html>
